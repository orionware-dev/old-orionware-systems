--instead of tasks calling other tasks, split them into smaller
tasks and the service itself should gather results from tasks and call the appropriate ones in the order it needs


--finish the template-project and apply everything I think of
to all the projects. Use core and datastructures as examples


--delete datastructures.testannotation.TestAnnotation


--figure out how a DataStructure.java object will encapsulate its size:
Use datastructuresservices.lists.size.impl.tasks.GetSizeTask



--CREATE CONVENIENT filter() AND forEach() IN OrionArrayList=========
enable the stream() so that I don't have to write it every time
methodsList.stream().filter((method) -> method != null).forEach(this::processMethod);
methodsList.filter((method) -> method != null).forEach(this::processMethod);



--CREATE CONVENIENT LAMBDA IF/THEN/ELSE========
so that we can have something like:
myObject.when(some != null).then(myObject::processMethod);



--in Filter.java there is the following method=======


@Override
public Object executeFilter()
{
    if(function instanceof OrionAbstractFunction)
    {
        return ((OrionAbstractFunction)function).executeFunction();
    }
    else if(function instanceof OrionServiceTask)
    {
        return ((OrionServiceTask)function).run();
    }
    
    return null;
}


instead of manually checking the instanceof, use configuration/Pipeline.prop in which I explicitly
declare the class types OrionAbstractFunction and OrionServiceTask and use that config to do
the checking in a loop with stream() like: for each class type, if function instanceof thisClassType,
return ((OrionAbstractFunction)function).run();


--NEW PROJECT GENERATOR dev tool=============
create a dev tool that after you create an empty project, it will generate the necessary general and
services dir and default interfaces and abstract classes, etc.



--for the @Injector, see if I can do something like this:
private Kitchen kitchen;
private Bedroom bedroom;
@Injector
House(Kitchen k, Bedroom b)
{
    this.kitchen = k;
    this.bedroom = b;
}
-make it a constructor annotation, but figure out how to avoid StackOverFlowError